<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>metaprogramming on Fundamenta Nova</title>
    <link>/tag/metaprogramming/</link>
    <description>Recent content in metaprogramming on Fundamenta Nova</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Jun 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/tag/metaprogramming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Passing expressions and data from R to C&#43;&#43; before compile-time in Rmarkdown</title>
      <link>/post/002_compile_time_data_r_to_cpp/main/</link>
      <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/002_compile_time_data_r_to_cpp/main/</guid>
      <description>


&lt;div id=&#34;introduction&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In this post we give a simple illustrative example of how data generated by R code can be used by compiled languages such as C++ at compile time, instead of run-time, inside Rmarkdown.&lt;/p&gt;
&lt;p&gt;This is an example of inter-language code generation. Metaprogramming/code generation is an extremely powerful technique but it’s also one that is very easy to overdo. This is just a fun example to learn from. Thorough testing is very important for any production code.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;using-other-languages-in-rmarkdown&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Using other languages in Rmarkdown&lt;/h2&gt;
&lt;p&gt;Out of the box Rmarkdown can work with the following languages assuming a proper back-end is available:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;names(knitr::knit_engines$get())&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;awk&amp;quot;         &amp;quot;bash&amp;quot;        &amp;quot;coffee&amp;quot;      &amp;quot;gawk&amp;quot;        &amp;quot;groovy&amp;quot;     
##  [6] &amp;quot;haskell&amp;quot;     &amp;quot;lein&amp;quot;        &amp;quot;mysql&amp;quot;       &amp;quot;node&amp;quot;        &amp;quot;octave&amp;quot;     
## [11] &amp;quot;perl&amp;quot;        &amp;quot;psql&amp;quot;        &amp;quot;Rscript&amp;quot;     &amp;quot;ruby&amp;quot;        &amp;quot;sas&amp;quot;        
## [16] &amp;quot;scala&amp;quot;       &amp;quot;sed&amp;quot;         &amp;quot;sh&amp;quot;          &amp;quot;stata&amp;quot;       &amp;quot;zsh&amp;quot;        
## [21] &amp;quot;highlight&amp;quot;   &amp;quot;Rcpp&amp;quot;        &amp;quot;tikz&amp;quot;        &amp;quot;dot&amp;quot;         &amp;quot;c&amp;quot;          
## [26] &amp;quot;fortran&amp;quot;     &amp;quot;fortran95&amp;quot;   &amp;quot;asy&amp;quot;         &amp;quot;cat&amp;quot;         &amp;quot;asis&amp;quot;       
## [31] &amp;quot;stan&amp;quot;        &amp;quot;block&amp;quot;       &amp;quot;block2&amp;quot;      &amp;quot;js&amp;quot;          &amp;quot;css&amp;quot;        
## [36] &amp;quot;sql&amp;quot;         &amp;quot;go&amp;quot;          &amp;quot;python&amp;quot;      &amp;quot;julia&amp;quot;       &amp;quot;sass&amp;quot;       
## [41] &amp;quot;scss&amp;quot;        &amp;quot;theorem&amp;quot;     &amp;quot;lemma&amp;quot;       &amp;quot;corollary&amp;quot;   &amp;quot;proposition&amp;quot;
## [46] &amp;quot;conjecture&amp;quot;  &amp;quot;definition&amp;quot;  &amp;quot;example&amp;quot;     &amp;quot;exercise&amp;quot;    &amp;quot;proof&amp;quot;      
## [51] &amp;quot;remark&amp;quot;      &amp;quot;solution&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although we can use R’s native foreign function interface to call compiled code, for C++ a higher level alternative is to use &lt;a href=&#34;https://cran.r-project.org/web/packages/Rcpp/index.html&#34;&gt;Rcpp&lt;/a&gt;. In Rmarkdown we can &lt;a href=&#34;https://bookdown.org/yihui/rmarkdown/language-engines.html#rcpp&#34;&gt;compile C++ code chunks using Rcpp and export the compiled functions to be available for use in R&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As a common example, we can compile the following code&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;Rcpp.h&amp;gt;
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) 
{
    return x * 2;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and use the exported function in R&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;timesTwo(1:10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  2  4  6  8 10 12 14 16 18 20&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;registering-a-user-defined-language-engine-in-knitr&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Registering a user-defined language engine in Knitr&lt;/h2&gt;
&lt;p&gt;We can create &lt;a href=&#34;https://bookdown.org/yihui/rmarkdown-cookbook/custom-engine.html&#34;&gt;user-defined engines&lt;/a&gt; to control exactly how the code chunk is sourced, or even modify existing engines. To get an idea we can look at the default Rcpp engine used by knitr:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;knitr::knit_engines$get()$Rcpp&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## function (options) 
## {
##     sourceCpp = getFromNamespace(&amp;quot;sourceCpp&amp;quot;, &amp;quot;Rcpp&amp;quot;)
##     code = one_string(options$code)
##     opts = options$engine.opts
##     cache = options$cache &amp;amp;&amp;amp; (&amp;quot;cacheDir&amp;quot; %in% names(formals(sourceCpp)))
##     if (cache) {
##         opts$cacheDir = paste(valid_path(options$cache.path, 
##             options$label), &amp;quot;sourceCpp&amp;quot;, sep = &amp;quot;_&amp;quot;)
##         opts$cleanupCacheDir = TRUE
##     }
##     if (!is.environment(opts$env)) 
##         opts$env = knit_global()
##     if (options$eval) {
##         message(&amp;quot;Building shared library for Rcpp code chunk...&amp;quot;)
##         do.call(sourceCpp, c(list(code = code), opts))
##     }
##     options$engine = &amp;quot;cpp&amp;quot;
##     engine_output(options, code, &amp;quot;&amp;quot;)
## }
## &amp;lt;environment: namespace:knitr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the default engine above as a template we can define a new knitr engine for compiling C++. One that can read and make use of more dynamic R data in C++ before compilation (or even dynamically create &lt;code&gt;Makevars&lt;/code&gt; files to control compilation flags). First let’s include the knitr package:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(knitr)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next let’s take a crack at defining a new engine to compile C++ code. In this example we will modify the current Rcpp engine to take in an &lt;code&gt;extra&lt;/code&gt; field (but otherwise behave the same).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;knit_engines$set(RcppFoo = function(options) {
    
    extra = options$extra
    
    sourceCpp = getFromNamespace(&amp;quot;sourceCpp&amp;quot;, &amp;quot;Rcpp&amp;quot;)
    
    ## Code is read as a list of strings, one list element per line
    ## Here we append extra code that may be defined in R to the 
    ## code written in the chunk
    code = c(extra, options$code)
    code = paste(code, collapse = &amp;#39;\n&amp;#39;)
    opts = options$engine.opts
    
    if (!is.environment(opts$env)) 
        opts$env = knit_global()

    if (options$eval) {    
        message(&amp;quot;Building shared library for Rcpp code chunk...&amp;quot;)
        do.call(sourceCpp, c(list(code = code), opts))
    }
    options$engine = &amp;quot;cpp&amp;quot;
    engine_output(options, 
                  options$code, 
                  paste(&amp;quot;Added the lines:\n&amp;quot;, 
                      paste(extra, collapse = &amp;#39;\n&amp;#39;), 
                      sep = &amp;#39;\n&amp;#39;))
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we test by creating some data in R and using that as a compile time constant in C++. Here we pass values of pi and e as static const doubles to C++ (a much cleaner API is possible of course).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;constants = list(
    paste(&amp;#39;static const double Pi =&amp;#39;, pi, &amp;#39;;&amp;#39;),
    paste(&amp;#39;static const double Euler =&amp;#39;, exp(1),&amp;#39;;&amp;#39;)
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This already highlights a danger as we have not considered exactly how R might convert these double precision floating point numbers to strings. Regardless, we proceed. To use the new engine we run the engine as &lt;code&gt;{RcppFoo test_chunk, extra = constants}&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;Rcpp.h&amp;gt;
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesFoo(NumericVector x) 
{
    return x * Pi + Euler;
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Added the lines:
## 
## static const double Pi = 3.14159265358979 ;
## static const double Euler = 2.71828182845905 ;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x = timesFoo(1:10)
print(x)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  5.859874  9.001467 12.143060 15.284652 18.426245 21.567838 24.709430
##  [8] 27.851023 30.992616 34.134208&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get &lt;strong&gt;almost&lt;/strong&gt; the same result as in R&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;y = pi*(1:10)+exp(1)
print(y)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  5.859874  9.001467 12.143060 15.284652 18.426245 21.567838 24.709430
##  [8] 27.851023 30.992616 34.134208&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But metaprogramming can be dangerous when mixed with floating point arithmetic. In this case some loss of precision occurred with the doubles when converting to strings:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x - y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  1.776357e-15  0.000000e+00 -3.552714e-15 -7.105427e-15 -1.065814e-14
##  [6] -1.421085e-14 -1.776357e-14 -1.776357e-14 -2.131628e-14 -2.842171e-14&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.double(as.character(pi))*(1:10) + as.double(as.character(exp(1))) - x&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00
##  [6] 3.552714e-15 3.552714e-15 0.000000e+00 0.000000e+00 0.000000e+00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Anyway this was just a small example. There are many many directions one can choose to take with metaprogramming. Even creating new preprocessing directives such as unrolling loops, defining constexprs, etc.&lt;/p&gt;
&lt;/div&gt;
</description>
      
            <category>metaprogramming</category>
      
            <category>rmarkdown</category>
      
            <category>c&#43;&#43;</category>
      
            <category>rcpp</category>
      
            <category>r</category>
      
      
            <category>C&#43;&#43;</category>
      
            <category>R</category>
      
    </item>
    
  </channel>
</rss>