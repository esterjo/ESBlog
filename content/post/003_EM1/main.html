---
title: "Expectation Maximization, Part 1: Motivation and Recipe"
author: "Edger Sterjo"
date: 2020-07-01
categories: ["Theory"]
tags: ["expectation maximization", "em algorithm","em"]
---



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This is the first in a series of posts on Expectation Maximization (EM) type algorithms. Our goal will be to motivate some of the theory behind these algorithms. In later posts we will implement examples in C++, often with the help of the <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a> linear algebra library.</p>
</div>
<div id="maximum-likelihood" class="section level2">
<h2>Maximum likelihood</h2>
<p>A large subset of statistics is concerned with determining properties of a distribution by using data that is assumed to be generated by that distribution. A common example is <a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation">Maximum Likelihood Estimation</a> (MLE). Here one assumes that a vector of observed data <span class="math inline">\(\vec{x}\in\mathbb{R}^N\)</span> is the realization of a random vector <span class="math inline">\(\vec{X}\)</span> with a probability density <span class="math inline">\(p(\vec{X} \ | \ \theta)\)</span> that depends on a vector of parameters <span class="math inline">\(\theta\)</span>. MLE amounts to estimating <span class="math inline">\(\theta\)</span> with the value that makes this probability density has high as possible for the observed data:</p>
<p><span class="math display">\[
\hat{\theta} := \text{argmax}_{\theta} \ \ p(\vec{x} \ | \ \theta)
\]</span>
As a function of <span class="math inline">\(\theta\)</span>, the density <span class="math inline">\(\mathcal{L}(\theta; \vec{x}) := p(\vec{x} \ | \ \theta)\)</span> is called the likelihood. Because probability densities are positive for the realized values <span class="math inline">\(\vec{x}\)</span> of <span class="math inline">\(\vec{X}\)</span>, the above problem is equivalent to maximizing the logarithm of the likelihood:
<span class="math display">\[
\hat{\theta} := \text{argmax}_{\theta} \ \ \log(p(\vec{x} \ | \ \theta))
\]</span>
(The main practical reason behind this log transformation is that it often makes the problem easier numerically. The theoretical advantage is that it ties MLE to the theory of the <a href="https://en.wikipedia.org/wiki/Fisher_information">Fisher Information</a>).</p>
</div>
<div id="dependence-structures-and-problems-with-hidden-variables" class="section level2">
<h2>Dependence structures and problems with hidden variables</h2>
<p>The situation in the last section can be summarized by the simple dependence structure (or <em>Markov</em> diagram) <span class="math inline">\(\theta \to \vec{X}\)</span>. That is, given the value of <span class="math inline">\(\theta\)</span> we can determined the distribution of <span class="math inline">\(\vec{X}\)</span>, namely <span class="math inline">\(p(\vec{X} \ | \ \theta)\)</span>.</p>
<p>However, in many applications we may only have partial observations of the data we want, with some of the relevant information remaining unobserved/hidden. For example, suppose 100 identical and independent dice are thrown in an experiment. The dice are not necessarily uniformly weighted, with probabilities of landing 1,2,…,6 given by <span class="math inline">\(\theta = [p_1, p_2,...,p_6]\)</span>. Suppose the dice land with values represented by <span class="math inline">\(\vec{X} = [X_1, X_2, ... X_{100}]\)</span> with <span class="math inline">\(X_i\)</span> being the number the <span class="math inline">\(i^{th}\)</span> die lands on. Suppose also that in the experiment we are only able to observe whether each die landed on an even or odd number. That is, we observe a vector <span class="math inline">\(\vec{Y}\)</span> given by</p>
<p><span class="math display">\[
Y_i = X_i \mod 2
\]</span></p>
<p>for <span class="math inline">\(i \in \{1, 2, ... 100\}\)</span>. In this case the dependence structure is a little more complex: <span class="math inline">\(\theta \to \vec{X} \to \vec{Y}\)</span>. That is, once we know the value of <span class="math inline">\(\vec{X}\)</span> we can fully specify the distribution of <span class="math inline">\(\vec{Y}\)</span> without knowing the value of <span class="math inline">\(\theta\)</span>. We would have the Markov property for densities:</p>
<p><span class="math display">\[
p(\vec{y} \ | \ \vec{x}, \theta) = p(\vec{y} \ | \ \vec{x})
\]</span></p>
<p>In general, we have a dependence structure given by <span class="math inline">\(\theta \to \vec{X} \to \vec{Y}\)</span>, we observe only <span class="math inline">\(\vec{Y}=\vec{y}\)</span> and we want to estimate the parameters <span class="math inline">\(\theta\)</span>. The MLE estimator would be:
<span class="math display">\[
\hat{\theta} := \text{argmax}_{\theta} \ \ \log(p(\vec{y} \ | \ \theta))
\]</span>
All of the theory of MLE applies in this case. In the example above this would be relatively easy. However, there are times this maximization problem is very difficult. Often the density <span class="math inline">\(p(\vec{y} \ | \ \theta)\)</span> may be much more complicated than the density <span class="math inline">\(p(\vec{x} \ | \ \theta)\)</span> of the hidden data that we wish we had.</p>
<p>In such as situation, if we knew <span class="math inline">\(\vec{x}\)</span> then we can replace the above problem with <span class="math inline">\(\hat{\theta} := \text{argmax}_{\theta} \ \ \log(p(\vec{x} \ | \ \theta))\)</span>. In fact, we wouldn’t even need to know exactly what the value of <span class="math inline">\(\vec{x}\)</span> is but only what the value of <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span> is for a given <span class="math inline">\(\theta\)</span>.</p>
</div>
<div id="a-general-recipe-for-em-algorithms" class="section level2">
<h2>A general recipe for EM algorithms</h2>
<p>The idea of EM is indeed to try and maximize <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span> instead of <span class="math inline">\(\log(p(\vec{y} \ | \ \theta))\)</span>, but because we do not know <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span> to instead use an approximation/estimate of it.</p>
<p>How to approximate such an expression? The quantity <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span> is a random variable (depending on the unknown value <span class="math inline">\(\vec{x}\)</span> of <span class="math inline">\(\vec{X}\)</span>). To estimate it in a meaningful way we need to use the most informative distribution related to <span class="math inline">\(\vec{x}\)</span>. Because we know <span class="math inline">\(\vec{y}\)</span> the best such distribution is <span class="math inline">\(p(\vec{x}|\vec{y},\theta)\)</span>.</p>
<p>The problem is this distribution (or any other) will necessarily depend <span class="math inline">\(\theta\)</span>, which we do not know! At first this seems like a circular trap, because to estimate <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span> using <span class="math inline">\(p(\vec{x}|\vec{y},\theta)\)</span> we need to know <span class="math inline">\(\theta\)</span>, but to estimate <span class="math inline">\(\theta\)</span> we need to know <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span>. However the trap hints at a solution: simply alternate between estimating the random variable <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span> using a current guess of <span class="math inline">\(\theta\)</span> and then use this updated estimate of <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span> to update our guess of <span class="math inline">\(\theta\)</span>. More formally we can summarize EM in 5 steps:</p>
<ul>
<li><p><strong>Step 1:</strong> Let <span class="math inline">\(m = 0\)</span>. Make an initial estimate <span class="math inline">\(\theta_m\)</span> for <span class="math inline">\(\theta\)</span>.</p></li>
<li><p><strong>Step 2:</strong> Given the observed data <span class="math inline">\(\vec{y}\)</span> and pretending for the moment that our current guess <span class="math inline">\(\theta_m\)</span> is correct, construct the conditional probability distribution <span class="math inline">\(p(\vec{x}|\vec{y},\theta_m)\)</span> of the hidden data <span class="math inline">\(\vec{x}\)</span> given all known information.</p></li>
<li><p><strong>Step 3:</strong> Using the distribution <span class="math inline">\(p(\vec{x}|\vec{y},\theta_m)\)</span> construct an estimator/approximation of the desired log-likelihood <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span> for arbitrary <span class="math inline">\(\theta\)</span>. We denote this approximation by <span class="math inline">\(Q(\theta|\theta_m)\)</span>.</p></li>
<li><p><strong>Step 4:</strong> Set <span class="math inline">\(\theta_{m+1}\)</span> equal to a value of <span class="math inline">\(\theta\)</span> that maximizes the current approximation <span class="math inline">\(Q(\theta|\theta_m)\)</span> of <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span>.</p></li>
<li><p><strong>Step 5:</strong> Return to step 2 and repeat until some stopping criteria is met.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p></li>
</ul>
<p>Practically speaking, this algorithm would be applied when each of these steps is significantly easier than the original MLE problem of <span class="math inline">\(\hat{\theta} := \text{argmax}_{\theta} \ \ \log(p(\vec{y} \ | \ \theta))\)</span>. As a general example, this is often the case when the model is linear with respect to <span class="math inline">\(\vec{X}\)</span>, but the information loss of going from <span class="math inline">\(\vec{X}\)</span> to <span class="math inline">\(\vec{Y}\)</span> is nonlinear and non-invertible (we’ll give examples in later posts).</p>
</div>
<div id="constructing-an-estimator-for-logpvecx-theta" class="section level2">
<h2>Constructing an estimator for <span class="math inline">\(\log(p(\vec{X} \ | \ \theta))\)</span></h2>
<p>How do we fill in the blank left by step 3 above? That is, how do we use the probability density <span class="math inline">\(p(\vec{x}|\vec{y},\theta_m)\)</span> to estimate the value of the random variable <span class="math inline">\(\log(p(\vec{X} \ | \ \theta))\)</span>? Two possibilities come to mind.</p>
<div id="point-estimate-type-em" class="section level3">
<h3>Point-estimate type EM</h3>
<p>One possibility is to let
<span class="math display">\[
\vec{x}_m = \vec{x}_m(\vec{y}, \theta_m) := \text{argmax}_{\vec{x}} \ p(\vec{x}|\vec{y},\theta_m)
\]</span>
and then define
<span class="math display">\[
Q(\theta | \theta_m) := \log(p(\vec{x}_m \ | \ \theta))
\]</span>
This is called point-estimate EM. Here we use “the most likely” value of <span class="math inline">\(\vec{X}\)</span> as determined by the density <span class="math inline">\(p(\vec{x}|\vec{y},\theta_m)\)</span> and then impute this value into our log-likelihood that we want to maximize. Another possibility would be to let</p>
<p><span class="math display">\[
\vec{x}_m = \vec{x}_m(\vec{y}, \theta_m) := \ \text{E}_{\vec{X} \ | \ \vec{Y} \ = \ \vec{y}, \ \theta_m}  \big[ \vec{X}\big]
\]</span>
and let <span class="math inline">\(Q\)</span> be as before.</p>
<p>The idea of these type of EM algorithms is to first estimate the missing data <span class="math inline">\(\vec{x}\)</span> and then impute the result into <span class="math inline">\(log(p(\vec{x}\ |\ \theta))\)</span>.</p>
</div>
<div id="expectation-em-i.e.-standard-em" class="section level3">
<h3>Expectation EM (i.e. standard EM)</h3>
<p>There is a theoretically more elegant way. As mentioned earlier, we do not in fact need an estimate of the missing data <span class="math inline">\(\vec{x}\)</span>. One of the best ways to estimate the value of a random variable with respect to a conditional distribution is to simply compute the conditional expectation of that variable with respect to that conditional distribution:</p>
<p><span class="math display">\[
Q(\theta | \theta_m) \ := \ \text{E}_{\vec{X} \ | \ \vec{Y} \ = \ \vec{y}, \ \theta_m}  \big[ \log(p(\vec{X} \ | \ \theta)) \big] = \int_{\mathcal{X}} \log(p(\vec{x} \ | \ \theta)) \ p(\vec{x}|\vec{y},\theta_m) \ d\vec{x} 
\]</span>
Here we’re computing the mean of <span class="math inline">\(\log(p(\vec{X} \ | \ \theta))\)</span> with respect to the density <span class="math inline">\(p(\vec{x}|\vec{y},\theta_m)\)</span>. As is common when using expectations, this second method has some advantages we’ll see later. When we refer to EM we will always mean this case, unless otherwise specified.</p>
</div>
</div>
<div id="qthetatheta_m-for-i.i.d.-samples" class="section level2">
<h2><span class="math inline">\(Q(\theta|\theta_m)\)</span> for I.I.D. samples</h2>
<p>So far everything has been rather general, applying to any random vectors <span class="math inline">\(\vec{X}\)</span> and <span class="math inline">\(\vec{Y}\)</span>. Many problems assume that data are generated independently and identically distributed (I.I.D.) so it’s helpful to have a formulation for this particular case.</p>
<p><strong>Proposition:</strong> Suppose that the components of <span class="math inline">\(\vec{X}\)</span> are IID (given <span class="math inline">\(\theta\)</span>), that is:
<span class="math display">\[
p(\vec{x}|\theta) = \prod_{i = 1}^N p(x_i|\theta) \  \qquad \forall x, \theta
\]</span>
Suppose also that the dependence structure <span class="math inline">\(\theta \to \vec{X} \to \vec{Y}\)</span> splits into subgraphs as <span class="math inline">\(\theta \to X_i \to Y_i\)</span> for all <span class="math inline">\(i = 1, 2, ..., N\)</span>. This just means that given <span class="math inline">\(X_i\)</span>, the distribution <span class="math inline">\(Y_i\)</span> is independent of all other variables:
<span class="math display">\[
p(y_i|\vec{x}, \theta, y_1, y_2, ..., y_{i-1}, y_{i+1}, ..., y_N) = p(y_i|x_i)
\]</span>
Then <span class="math inline">\(Q(\theta|\theta_m):= \ \text{E}_{\vec{X} \ | \ \vec{Y} \ = \ \vec{y}, \ \theta_m} \big[ \log(p(\vec{X} \ | \ \theta)) \big]\)</span> can be written as:
<span class="math display">\[
Q(\theta|\theta_m) = \sum_{i=1}^N Q_i(\theta|\theta_m)
\]</span>
where
<span class="math display">\[
Q_i(\theta|\theta_m) := \ \text{E}_{X_i \ | \ Y_i \ = \ y_i, \ \theta_m}  \big[ \log(p(X_i \ | \ \theta)) \big].
\]</span>
<strong>Proof:</strong> The proof begins by showing that the joint elements <span class="math inline">\((X_i,Y_i)\)</span> are independent across <span class="math inline">\(i\)</span>, that is:
<span class="math display">\[
p(\vec{x},\vec{y}|\theta) = \prod_{i = 1}^N p(x_i, y_i|\theta). 
\]</span>
To prove this we start by applying the multiplication theorem for probability densities:
<span class="math display">\[\begin{equation}
  \begin{aligned}

p(\vec{x},\vec{y}|\theta) &amp;= p(y_1|y_2,y_3, ..., y_N, \vec{x},\theta)...p(y_N|\vec{x},\theta)p(\vec{x}|\theta) \qquad \text{by the multiplication theorem}\\

    &amp;= p(y_1|x_1,\theta)...p(y_N|x_N,\theta)p(\vec{x}|\theta) \qquad \text{by conditional independence but keeping theta} \\
    &amp;= p(\vec{x}|\theta)\prod_{i=1}^Np(y_i|x_i,\theta) \\
    &amp;=\prod_{i=1}^Np(y_i|x_i,\theta)p(x_i|\theta) \qquad \text{by independence of the x&#39;s} \\
    &amp;= \prod_{i=1}^Np(y_i,x_i|\theta).
  \end{aligned}
\end{equation}\]</span></p>
<p>Next we have that for each <span class="math inline">\(i\)</span></p>
<p><span class="math display">\[\begin{equation}
  \begin{aligned}
  
  p(x_i|\vec{y},\theta) &amp;= \frac{p(x_i,\vec{y}|\theta)}{p(\vec{y}|\theta)} \qquad \text{by Bayes} \\
  
  &amp;= \frac{\int p(\vec{x},\vec{y}|\theta)dx_1...dx_{i-1}dx_{i+1}...dx_n}{\int p(\vec{x},\vec{y}|\theta)d\vec{x}} \\
  
  &amp;= \frac{\int \prod_{j=1}^Np(y_j,x_j|\theta)dx_1...dx_{i-1}dx_{i+1}...dx_n}{\int \prod_{j=1}^Np(y_j,x_j|\theta)d\vec{x}} \\
  
  &amp;= \frac{p(x_i,y_i|\theta) \prod_{j=1, j \ne i}^N \int p(y_j,x_j|\theta)dx_j}{\prod_{j=1}^N\int p(y_j,x_j|\theta) dx_j} \\
  
  &amp;= \frac{p(x_i,y_i|\theta) \prod_{j=1, j \ne i}^N p(y_j|\theta)}{\prod_{j=1}^N p(y_j|\theta)}\\
  
  &amp;= \frac{p(x_i,y_i|\theta)}{p(y_i|\theta)}\\
  
  &amp;= p(x_i|y_i,\theta)

  \end{aligned}
\end{equation}\]</span></p>
<p>Hence <span class="math inline">\(p(x_i|\vec{y},\theta) = p(x_i|y_i,\theta)\)</span>. Therefore we have</p>
<p><span class="math display">\[\begin{equation}
  \begin{aligned}
  
  Q(\theta, \theta_m) &amp;= \text{E}_{\vec{X} \ | \ \vec{Y} \ = \ \vec{y}, \ \theta_m}  \big[ \log(p(\vec{X} \ | \ \theta)) \big] \\
  
  &amp;= \text{E}_{\vec{X} \ | \ \vec{Y} \ = \ \vec{y}, \ \theta_m}  \big[ \log(\prod_{i = 1}^N p(X_i \ | \ \theta)) \big] \\
  
  &amp;= \text{E}_{\vec{X} \ | \ \vec{Y} \ = \ \vec{y}, \ \theta_m}  \big[ \sum_{i = 1}^N \log(p(X_i \ | \ \theta)) \big]\\
  
  &amp;= \sum_{i = 1}^N \text{E}_{X_i \ | \ \vec{Y} \ = \ \vec{y}, \ \theta_m}  \big[ \log(p(X_i \ | \ \theta)) \big] \\
  
  &amp;= \sum_{i = 1}^N \text{E}_{X_i \ | \ Y_i \ = \ y_i, \ \theta_m}  \big[ \log(p(X_i \ | \ \theta)) \big]
  
  = \sum_{i=1}^N Q_i(\theta|\theta_m)

  \end{aligned}
\end{equation}\]</span>
Where we used <span class="math inline">\(p(x_i|\vec{y},\theta) = p(x_i|y_i,\theta)\)</span> in the 2nd to last equality. <strong>QED</strong></p>
</div>
<div id="maximum-a-posteriori-em-and-regularizing-priors" class="section level2">
<h2>Maximum A Posteriori EM and regularizing priors</h2>
<p>The EM algorithm is easily extendable to regularized MLE. This is usually referred to as Maximum A Posteriori (MAP) in the Bayesian setting, which we adopt. Here the penalty term is interpreted as the log of the prior density on <span class="math inline">\(\theta\)</span>, and the function to be maximized is the posterior density of <span class="math inline">\(\theta\)</span> given the data. By Bayes’ Theorem
<span class="math display">\[
p(\theta|\vec{y}) \propto p(\vec{y}|\theta)p(\theta)
\]</span>
where the proportionality constant is independent of <span class="math inline">\(\theta\)</span>. Thus the MAP estimator is
<span class="math display">\[
\hat{\theta}_{MAP} := \text{argmax}_{\theta} \ \log(p(\theta|\vec{y})) \ = \text{argmax}_{\theta} \ \log(p(\vec{y}|\theta)) + \log(p(\theta))
\]</span>
The way to extend EM to this situation is clear (at least formally): Simply replace the maximization step (step 4 above) in EM with maximizing <span class="math inline">\(Q(\theta|\theta_m) + \log(p(\theta))\)</span> instead of simply <span class="math inline">\(Q(\theta|\theta_m)\)</span>:</p>
<p><span class="math display">\[
\theta_{m+1} := \text{argmax}_{\theta} \ \ \ Q(\theta|\theta_m) + \log(p(\theta))
\]</span>
where as before <span class="math inline">\(Q\)</span> is given by</p>
<p><span class="math display">\[
Q(\theta | \theta_m) \ := \ \text{E}_{\vec{X} \ | \ \vec{Y} \ = \ \vec{y}, \ \theta_m}  \big[ \log(p(\vec{X} \ | \ \theta)) \big] = \int_{\mathcal{X}} \log(p(\vec{x} \ | \ \theta)) \ p(\vec{x}|\vec{y},\theta_m) \ d\vec{x} 
\]</span></p>
</div>
<div id="monotonicity-of-the-em-algorithm" class="section level2">
<h2>Monotonicity of the EM algorithm</h2>
<p>At this point the reader has all the theory needed to begin applying EM where they believe it’s a good fit. Before we end the post though let’s mention at least one result that shows that EM is indeed a generalization of MLE to the case of hidden data: under relatively weak assumptions of the algorithm causes the log-likelihood <span class="math inline">\(\log(p(\vec{y}|\theta_m))\)</span> to be an <a href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm#Proof_of_correctness">increasing sequence in <span class="math inline">\(m\)</span></a>.</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Step 2 allows for a whole family of such algorithms, one for each possible approximator to <span class="math inline">\(\log(p(\vec{x} \ | \ \theta))\)</span>. Step 4 can also be generalized. Since the value of <span class="math inline">\(\theta_{m+1}\)</span> maximizes <span class="math inline">\(Q(\theta | \theta_m)\)</span> then <span class="math inline">\(Q(\theta_{m+1} | \theta_m) \ge Q(\theta_m | \theta_m)\)</span>. Instead of seeking to maximize <span class="math inline">\(Q(\theta | \theta_m)\)</span> we may simply seek a value of <span class="math inline">\(\theta_{m+1}\)</span> that improves on <span class="math inline">\(\theta_m\)</span> in the sense of this inequality. For step 5, the stopping criteria are up to the implementer.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
