---
title: "Communicating compile-time expressions from R to C++ in Rmarkdown"
author: "Edger Sterjo"
date: 2020-06-20
categories: ["C++", "R"]
tags: ["metaprogramming", "rmarkdown", "mcmc", "eigen", "c++", "rcpp", "r"]
---


## Introduction

In this post we give a simple illustrative example of how data generated by R code can be used by compiled languages such as C++ at compile time, instead of run-time, inside Rmarkdown.

A word of warning before we go further. It's easy to overdo it when it comes to metaprogramming/code generation like this. Personally I prefer to use less of it than more of it. This is just a fun example to learn more.


## Using other languages in Rmarkdown

Out of the box Rmarkdown can work with the following languages assuming a proper back-end is available:

```{r}
names(knitr::knit_engines$get())
```
Although we can use R's foreign function interface to call compiled code, for C++ a higher level alternative is to use [Rcpp](https://cran.r-project.org/web/packages/Rcpp/index.html). In Rmarkdown we can [compile C++ code chunks using Rcpp and export the compiled functions to be available for use in R](https://bookdown.org/yihui/rmarkdown/language-engines.html#rcpp).

As a canonical example, we can compile the following code
```{Rcpp my_chunk, cache=TRUE, engine.opts = list(verbose=TRUE)}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) 
{
	return x * 2;
}
```
and use the exported function in R
```{r}
timesTwo(1:10)
```


## Registering a user-defined language engine in Knitr

We can also create [user-defined engines](https://bookdown.org/yihui/rmarkdown-cookbook/custom-engine.html) to control exactly how the code chunk is sourced. To get an idea we can look at the default Rcpp engine used by knitr:

```{r}
knitr::knit_engines$get()$Rcpp
```

Using the default Rcpp engine above as a template we can define a new knitr engine for compiling C++. One that can read and make use of more dynamic R data. First let's include the knitr package and define some utility functions:


```{r}
library(knitr)

# Concatenate list of strings using a delimiter of \n (similar 
# to what is used internally by knitr)
concat_lines = function(x, ...) paste(x, ..., collapse = '\n')
```

Next let's take a crack at defining a new engine to compile C++ code. In this example we will pass the new data as part of the engine.opts field of the chunk:
```{r}
knit_engines$set(RcppFoo = function(options) {
	
	sourceCpp = getFromNamespace("sourceCpp", "Rcpp")
	opts = options$engine.opts
	extra = opts$extra
	opts$extra = NULL
	
	## Code is read as a list of strings, one list element per line
	## Here we append extra code that may be defined in R to the 
	## code written in the chunk
	code = c(extra, options$code)
    code = concat_lines(code)
    
    cache = options$cache && ("cacheDir" %in% names(formals(sourceCpp)))
    if (cache) {
        opts$cacheDir = paste(valid_path(options$cache.path, 
            options$label), "sourceCpp", sep = "_")
        opts$cleanupCacheDir = TRUE
    }
    if (!is.environment(opts$env)) 
        opts$env = knit_global()

    if (options$eval) {    
		message("Building shared library for Rcpp code chunk...")
		do.call(sourceCpp, c(list(code = code), opts))
    }
    options$engine = "cpp"
    engine_output(options, 
    			  options$code, 
    			  paste("Added the lines: ", concat_lines(extra), sep = '\n'))
})
```

Next we test by creating some data in R and using that as a compile time constant in C++:

```{r}
constants = list(
	paste('static const double Pi =', pi, ';'),
	paste('static const double Euler =', exp(1),';')
)
```
To use the new engine we run the engine as `{RcppFoo test_chunk, engine.opts = list(extra = constants)}`

```{RcppFoo test_chunk, engine.opts = list(extra = constants)}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesFoo(NumericVector x) 
{
	return x * Pi + Euler;
}
```


```{r}
timesFoo(1:10)
pi*(1:10)+exp(1)
```
