---
title: "Parallel Monte Carlo: Simulating Compound Poisson Processes using C++ and TBB"
author: "Edger Sterjo"
date: 2020-11-20
categories: ["C++", "R", "TBB"]
tags: ["parallel", "monte carlo", "poisson", "c++", "operational risk", "rcpp", "r"]
---



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>In this post we implement a function to simulate random samples of a <a href="https://en.wikipedia.org/wiki/Compound_Poisson_process">Compound Poisson variable</a>. A random variable <span class="math inline">\(L\)</span> is a compound Poisson (CP) random variable if there exists a Poisson random variable <span class="math inline">\(N\)</span>, and a random variable <span class="math inline">\(S\)</span> such that</p>
<p><span class="math display">\[
L = \sum_{i = 1}^N S_i
\]</span></p>
<p>where <span class="math inline">\(S_i\)</span> for <span class="math inline">\(i \in \mathbb{N}\)</span> is an IID sequence of random variables with the same distribution as <span class="math inline">\(S\)</span> and that are independent of <span class="math inline">\(N\)</span>. This kind of expression is typical in operational risk modeling, insurance modeling, and <a href="https://en.wikipedia.org/wiki/Ruin_theory">ruin theory</a>. Typically, the variable <span class="math inline">\(N\)</span> is a counter for the occurrence of loss events to an insurance portfolio over a given time period, and <span class="math inline">\(S_i\)</span> is the severity of the <span class="math inline">\(i\)</span>-th loss event. A CP variable/process is the most common approach banks take to model operational risk as part of their <a href="https://en.wikipedia.org/wiki/Advanced_measurement_approach">Advanced Measurement Approach</a>. The advantage of this model in operational risk is that losses (and hence data) tend to be sparse in this domain. In addition, losses tend to be heavy tailed. By splitting event frequency (<span class="math inline">\(N\)</span>) from event severity (<span class="math inline">\(S\)</span>) the model developer can use more data to fit loss event distributions and loss frequency distributions independently (after accepting the assumptions of the CP process). Allowing one to focus on fitting the tail of the loss distribution, without having to worry about the frequency of occurrences.</p>
<p>We’ll implement a function that simulates random samples of <span class="math inline">\(L\)</span> in R, serially in C++, and in parallel in C++ using the <a href="https://github.com/oneapi-src/oneTBB">Threading Building Blocks (TBB)</a> library.</p>
</div>
<div id="r-implementation" class="section level2">
<h2>R Implementation</h2>
<p>R is extremely expressive when it comes to mathematical, statistical, and graphing operations and the base implementation is quite simple:</p>
<pre class="r"><code>## Function to simulate random samples from a CP variable with 
## log-normal severities
rCP = function(lambda, mu, sigma, N)
{
    sapply(1:N, FUN = function(dummy){
        sum(rlnorm(n = rpois(1, lambda), meanlog = mu, sdlog = sigma))
    })
}</code></pre>
</div>
<div id="serial-c-implementation" class="section level2">
<h2>Serial C++ Implementation</h2>
<p>We now implement the sampler in C++ using the <a href="http://www.rcpp.org/">Rcpp package</a>. We will also make use of the <a href="https://cran.r-project.org/web/packages/dqrng/index.html">dqrng</a> package so that we can conveniently include the <a href="https://www.pcg-random.org/">PCG</a> random number generator by Melissa O’Neil.</p>
<pre class="cpp"><code>#include &lt;Rcpp.h&gt;

// [[Rcpp::depends(dqrng)]]
// [[Rcpp::plugins(cpp11)]]

#include &lt;pcg_random.hpp&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;

// [[Rcpp::export]]
Rcpp::NumericVector cppCP(const double lambda,
                          const double mu,
                          const double sigma,
                          const int N)
{
    // Seed with a real random value, if available
    pcg_extras::seed_seq_from&lt;std::random_device&gt; seed_source;

    // Make a random number engine
    pcg64 rng(seed_source);
    
    // Distribution for frequency
    std::poisson_distribution&lt;int&gt; Freq(lambda);
    
    // Distribution for severity
    std::lognormal_distribution&lt;double&gt; Sev(mu, sigma);
    
    // Allocate vector
    Rcpp::NumericVector out(N);

    // Simulate samples
    std::generate(out.begin(), out.end(), [&amp;](){
        
        // Simulating loss event count
        int n = Freq(rng);
        
        // Accumulating loss severities
        double s = 0;
        for(int i = 0; i &lt; n; ++i) s += Sev(rng);
        
        return s;
    });
    
    return out;
}</code></pre>
<pre class="r"><code>x_r = rCP(lambda = 1.7, mu = 5.5, sigma = 2.5, N = 10^6)
x_cpp = cppCP(lambda = 1.7, mu = 5.5, sigma = 2.5, N = 10^6)

ks.test(x = x_r, y = x_cpp, alternative = &quot;two.sided&quot;)</code></pre>
<pre><code>## Warning in ks.test(x = x_r, y = x_cpp, alternative = &quot;two.sided&quot;): p-value will
## be approximate in the presence of ties</code></pre>
<pre><code>## 
##  Two-sample Kolmogorov-Smirnov test
## 
## data:  x_r and x_cpp
## D = 0.001113, p-value = 0.5654
## alternative hypothesis: two-sided</code></pre>
<pre class="r"><code>microbenchmark::microbenchmark(
    &quot;R&quot; = rCP(lambda = 1.7, mu = 5.5, sigma = 2.5, N = 10^6),
    &quot;C++&quot; = cppCP(lambda = 1.7, mu = 5.5, sigma = 2.5, N = 10^6),
    times = 10L
    )</code></pre>
<pre><code>## Unit: milliseconds
##  expr       min        lq      mean    median        uq       max neval
##     R 4493.2542 4681.6711 4823.3279 4786.7206 5051.4572 5104.8304    10
##   C++  152.9929  156.1746  158.0281  156.6728  159.5525  165.4695    10</code></pre>
<p>We see that a Kolmogorov-Smirnov test for equality of distributions shows that the two samples aren’t statistically distinct. Also the C++ version is ~30 times faster than the R version. Note that we added the compilation flags <code>-O3 -march=native</code> to the Makevars file in our Documents/.R folder.</p>
</div>
<div id="parallel-c-implementation" class="section level2">
<h2>Parallel C++ Implementation</h2>
<p>There are many libraries we can use to parallelize the C++ code above. These include <a href="https://www.openmp.org/">OpenMP</a> and <a href="https://www.openacc.org/">OpenACC</a> (both of which allow for standards based parallelization through directive based APIs, with newer standards allowing for GPU offloading), <a href="https://www.open-mpi.org/">MPI</a> and <a href="https://www.boost.org/doc/libs/1_74_0/doc/html/mpi.html">Boost.MPI</a> for distributed messaging passing, <a href="https://github.com/kokkos/kokkos">Kokkos</a>, <a href="https://github.com/taskflow/taskflow">Taskflow</a>, <a href="https://github.com/boostorg/compute">Boost.Compute</a>, <a href="https://github.com/STEllAR-GROUP/hpx/">HPX</a>, etc.</p>
<p>However, <a href="https://rcppcore.github.io/RcppParallel/tbb.html">Threading Building Blocks (TBB)</a> is very powerful, expressive, mature, and is very conveniently included in the <a href="https://rcppcore.github.io/RcppParallel/">RcppParallel</a> package. I find TBB’s API to be very well designed. So TBB it is!</p>
<pre class="cpp"><code>#include &lt;Rcpp.h&gt;
#include &lt;RcppParallel.h&gt;

// [[Rcpp::depends(dqrng, RcppParallel)]]
// [[Rcpp::plugins(cpp11)]]

#include &lt;pcg_random.hpp&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;



// [[Rcpp::export]]
Rcpp::NumericVector tbbCP(const double lambda,
                          const double mu,
                          const double sigma,
                          const int N,
                          const uint64_t seed)
{
    using brange = tbb::blocked_range&lt;size_t&gt;;
    
    // Allocate vector
    Rcpp::NumericVector out(N);
    
    // Getting pointer to data
    auto begin = out.begin();
    
    tbb::parallel_for(brange(0, N), [=](brange&amp; range){
        
        // Distribution for frequency
        std::poisson_distribution&lt;int&gt; Freq(lambda);
    
        // Distribution for severity
        std::lognormal_distribution&lt;double&gt; Sev(mu, sigma);
        
        // RNG local to thread, with unique stream
        pcg64 rng(seed, range.end());
        
        // Serial version of sampler
        auto seq_CP = [&amp;](){
            
            // Simulating loss event count
            int n = Freq(rng);
            
            // Accumulating loss severities
            double s = 0;
            for(int i = 0; i &lt; n; ++i) s += Sev(rng);
            
            return s;
        };
        
        // Loop to simulate samples
        std::generate(begin + range.begin(), begin + range.end(), seq_CP);
    });
    
    return out;
}</code></pre>
<p>C++11 and TBB allow for pretty parallel code. Let’s see if this function is as useful as it is pretty.</p>
<pre class="r"><code>x_tbb = tbbCP(lambda = 1.7, mu = 5.5, sigma = 2.5, N = 10^6, seed = 42)

ks.test(x = x_cpp, y = x_tbb, alternative = &quot;two.sided&quot;)</code></pre>
<pre><code>## Warning in ks.test(x = x_cpp, y = x_tbb, alternative = &quot;two.sided&quot;): p-value
## will be approximate in the presence of ties</code></pre>
<pre><code>## 
##  Two-sample Kolmogorov-Smirnov test
## 
## data:  x_cpp and x_tbb
## D = 0.001094, p-value = 0.5877
## alternative hypothesis: two-sided</code></pre>
<pre class="r"><code>ks.test(x = x_r, y = x_tbb, alternative = &quot;two.sided&quot;)</code></pre>
<pre><code>## Warning in ks.test(x = x_r, y = x_tbb, alternative = &quot;two.sided&quot;): p-value will
## be approximate in the presence of ties</code></pre>
<pre><code>## 
##  Two-sample Kolmogorov-Smirnov test
## 
## data:  x_r and x_tbb
## D = 0.001379, p-value = 0.2977
## alternative hypothesis: two-sided</code></pre>
<p>The Kolmogorov-Smirnov test again can’t tell the samples apart between R, serial C++, and TBB implementations. As for performance:</p>
<pre class="r"><code>microbenchmark::microbenchmark(
    &quot;R&quot; = rCP(lambda = 1.7, mu = 5.5, sigma = 2.5, N = 10^6),
    &quot;C++&quot; = cppCP(lambda = 1.7, mu = 5.5, sigma = 2.5, N = 10^6),
    &quot;TBB&quot; = tbbCP(lambda = 1.7, mu = 5.5, sigma = 2.5, N = 10^6, seed = 42),
    times = 10L
    )</code></pre>
<pre><code>## Unit: milliseconds
##  expr       min        lq       mean    median        uq       max neval
##     R 4510.9116 4847.8254 4861.47488 4878.6472 4887.1488 5108.7465    10
##   C++  153.7255  155.1583  157.70383  155.8393  157.7901  167.4164    10
##   TBB   17.7385   17.8813   22.56139   19.3085   28.7204   29.5262    10</code></pre>
<p>TBB ran ~8 times faster than the serial version. The algorithm’s runtime scales linearly with <span class="math inline">\(\lambda\)</span>, so let’s compare the two C++ versions with a higher lambda:</p>
<pre class="r"><code>microbenchmark::microbenchmark(
    &quot;C++&quot; = cppCP(lambda = 17, mu = 5.5, sigma = 2.5, N = 10^6),
    &quot;TBB&quot; = tbbCP(lambda = 17, mu = 5.5, sigma = 2.5, N = 10^6, seed = 42),
    times = 50L
    )</code></pre>
<pre><code>## Unit: milliseconds
##  expr       min        lq      mean    median        uq       max neval
##   C++ 1388.7126 1398.7598 1401.8384 1401.6124 1404.7762 1427.1751    50
##   TBB  147.0726  147.4528  148.7259  147.5522  148.9511  154.5965    50</code></pre>
<p>TBB ran ~9.5 times faster than the serial version.</p>
</div>
