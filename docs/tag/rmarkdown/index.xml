<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rmarkdown | Fundamenta Nova</title>
    <link>/tag/rmarkdown/</link>
      <atom:link href="/tag/rmarkdown/index.xml" rel="self" type="application/rss+xml" />
    <description>rmarkdown</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 21 Jun 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>rmarkdown</title>
      <link>/tag/rmarkdown/</link>
    </image>
    
    <item>
      <title>Passing expressions and data from R to C&#43;&#43; before compile-time in Rmarkdown</title>
      <link>/post/002_compile_time_data_r_to_cpp/main/</link>
      <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/post/002_compile_time_data_r_to_cpp/main/</guid>
      <description>IntroductionIn this post we give a simple illustrative example of how data generated by R code can be used by compiled languages such as C++ at compile time, instead of run-time, inside Rmarkdown.</description>
      <content:encoded>


<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>In this post we give a simple illustrative example of how data generated by R code can be used by compiled languages such as C++ at compile time, instead of run-time, inside Rmarkdown.</p>
<p>This is an example of inter-language code generation. Metaprogramming/code generation is an extremely powerful technique but it’s also one that is very easy to overdo. This is just a fun example to learn from. Thorough testing is very important for any production code.</p>
</div>
<div id="using-other-languages-in-rmarkdown" class="section level2">
<h2>Using other languages in Rmarkdown</h2>
<p>Out of the box Rmarkdown can work with the following languages assuming a proper back-end is available:</p>
<pre class="r"><code>names(knitr::knit_engines$get())</code></pre>
<pre><code>##  [1] &quot;awk&quot;         &quot;bash&quot;        &quot;coffee&quot;      &quot;gawk&quot;        &quot;groovy&quot;     
##  [6] &quot;haskell&quot;     &quot;lein&quot;        &quot;mysql&quot;       &quot;node&quot;        &quot;octave&quot;     
## [11] &quot;perl&quot;        &quot;psql&quot;        &quot;Rscript&quot;     &quot;ruby&quot;        &quot;sas&quot;        
## [16] &quot;scala&quot;       &quot;sed&quot;         &quot;sh&quot;          &quot;stata&quot;       &quot;zsh&quot;        
## [21] &quot;highlight&quot;   &quot;Rcpp&quot;        &quot;tikz&quot;        &quot;dot&quot;         &quot;c&quot;          
## [26] &quot;fortran&quot;     &quot;fortran95&quot;   &quot;asy&quot;         &quot;cat&quot;         &quot;asis&quot;       
## [31] &quot;stan&quot;        &quot;block&quot;       &quot;block2&quot;      &quot;js&quot;          &quot;css&quot;        
## [36] &quot;sql&quot;         &quot;go&quot;          &quot;python&quot;      &quot;julia&quot;       &quot;sass&quot;       
## [41] &quot;scss&quot;        &quot;theorem&quot;     &quot;lemma&quot;       &quot;corollary&quot;   &quot;proposition&quot;
## [46] &quot;conjecture&quot;  &quot;definition&quot;  &quot;example&quot;     &quot;exercise&quot;    &quot;proof&quot;      
## [51] &quot;remark&quot;      &quot;solution&quot;</code></pre>
<p>Although we can use R’s native foreign function interface to call compiled code, for C++ a higher level alternative is to use <a href="https://cran.r-project.org/web/packages/Rcpp/index.html">Rcpp</a>. In Rmarkdown we can <a href="https://bookdown.org/yihui/rmarkdown/language-engines.html#rcpp">compile C++ code chunks using Rcpp and export the compiled functions to be available for use in R</a>.</p>
<p>As a common example, we can compile the following code</p>
<pre class="cpp"><code>#include &lt;Rcpp.h&gt;
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) 
{
    return x * 2;
}</code></pre>
<p>and use the exported function in R</p>
<pre class="r"><code>timesTwo(1:10)</code></pre>
<pre><code>##  [1]  2  4  6  8 10 12 14 16 18 20</code></pre>
</div>
<div id="registering-a-user-defined-language-engine-in-knitr" class="section level2">
<h2>Registering a user-defined language engine in Knitr</h2>
<p>We can create <a href="https://bookdown.org/yihui/rmarkdown-cookbook/custom-engine.html">user-defined engines</a> to control exactly how the code chunk is sourced, or even modify existing engines. To get an idea we can look at the default Rcpp engine used by knitr:</p>
<pre class="r"><code>knitr::knit_engines$get()$Rcpp</code></pre>
<pre><code>## function (options) 
## {
##     sourceCpp = getFromNamespace(&quot;sourceCpp&quot;, &quot;Rcpp&quot;)
##     code = one_string(options$code)
##     opts = options$engine.opts
##     cache = options$cache &amp;&amp; (&quot;cacheDir&quot; %in% names(formals(sourceCpp)))
##     if (cache) {
##         opts$cacheDir = paste(valid_path(options$cache.path, 
##             options$label), &quot;sourceCpp&quot;, sep = &quot;_&quot;)
##         opts$cleanupCacheDir = TRUE
##     }
##     if (!is.environment(opts$env)) 
##         opts$env = knit_global()
##     if (options$eval) {
##         message(&quot;Building shared library for Rcpp code chunk...&quot;)
##         do.call(sourceCpp, c(list(code = code), opts))
##     }
##     options$engine = &quot;cpp&quot;
##     engine_output(options, code, &quot;&quot;)
## }
## &lt;environment: namespace:knitr&gt;</code></pre>
<p>Using the default engine above as a template we can define a new knitr engine for compiling C++. One that can read and make use of more dynamic R data in C++ before compilation (or even dynamically create <code>Makevars</code> files to control compilation flags). First let’s include the knitr package:</p>
<pre class="r"><code>library(knitr)</code></pre>
<p>Next let’s take a crack at defining a new engine to compile C++ code. In this example we will modify the current Rcpp engine to take in an <code>extra</code> field (but otherwise behave the same).</p>
<pre class="r"><code>knit_engines$set(RcppFoo = function(options) {
    
    extra = options$extra
    
    sourceCpp = getFromNamespace(&quot;sourceCpp&quot;, &quot;Rcpp&quot;)
    
    ## Code is read as a list of strings, one list element per line
    ## Here we append extra code that may be defined in R to the 
    ## code written in the chunk
    code = c(extra, options$code)
    code = paste(code, collapse = &#39;\n&#39;)
    opts = options$engine.opts
    
    if (!is.environment(opts$env)) 
        opts$env = knit_global()

    if (options$eval) {    
        message(&quot;Building shared library for Rcpp code chunk...&quot;)
        do.call(sourceCpp, c(list(code = code), opts))
    }
    options$engine = &quot;cpp&quot;
    engine_output(options, 
                  options$code, 
                  paste(&quot;Added the lines:\n&quot;, 
                      paste(extra, collapse = &#39;\n&#39;), 
                      sep = &#39;\n&#39;))
})</code></pre>
<p>Next we test by creating some data in R and using that as a compile time constant in C++. Here we pass values of pi and e as static const doubles to C++ (a much cleaner API is possible of course).</p>
<pre class="r"><code>constants = list(
    paste(&#39;static const double Pi =&#39;, pi, &#39;;&#39;),
    paste(&#39;static const double Euler =&#39;, exp(1),&#39;;&#39;)
)</code></pre>
<p>This already highlights a danger as we have not considered exactly how R might convert these double precision floating point numbers to strings. Regardless, we proceed. To use the new engine we run the engine as <code>{RcppFoo test_chunk, extra = constants}</code></p>
<pre class="cpp"><code>#include &lt;Rcpp.h&gt;
using namespace Rcpp;

// [[Rcpp::export]]
NumericVector timesFoo(NumericVector x) 
{
    return x * Pi + Euler;
}</code></pre>
<pre><code>## Added the lines:
## 
## static const double Pi = 3.14159265358979 ;
## static const double Euler = 2.71828182845905 ;</code></pre>
<pre class="r"><code>x = timesFoo(1:10)
print(x)</code></pre>
<pre><code>##  [1]  5.859874  9.001467 12.143060 15.284652 18.426245 21.567838 24.709430
##  [8] 27.851023 30.992616 34.134208</code></pre>
<p>We get <strong>almost</strong> the same result as in R</p>
<pre class="r"><code>y = pi*(1:10)+exp(1)
print(y)</code></pre>
<pre><code>##  [1]  5.859874  9.001467 12.143060 15.284652 18.426245 21.567838 24.709430
##  [8] 27.851023 30.992616 34.134208</code></pre>
<p>But metaprogramming can be dangerous when mixed with floating point arithmetic. In this case some loss of precision occurred with the doubles when converting to strings:</p>
<pre class="r"><code>x - y</code></pre>
<pre><code>##  [1]  1.776357e-15  0.000000e+00 -3.552714e-15 -7.105427e-15 -1.065814e-14
##  [6] -1.421085e-14 -1.776357e-14 -1.776357e-14 -2.131628e-14 -2.842171e-14</code></pre>
<pre class="r"><code>as.double(as.character(pi))*(1:10) + as.double(as.character(exp(1))) - x</code></pre>
<pre><code>##  [1] 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00 0.000000e+00
##  [6] 3.552714e-15 3.552714e-15 0.000000e+00 0.000000e+00 0.000000e+00</code></pre>
<p>Anyway this was just a small example. There are many many directions one can choose to take with metaprogramming. Even creating new preprocessing directives such as unrolling loops, defining constexprs, etc.</p>
</div>
</content:encoded>	
    </item>
    
  </channel>
</rss>
